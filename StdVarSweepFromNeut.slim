// Wed 21st Nov 2018
// Modification of recipe 10.6.1
// Selective sweep at a neutral locus from std variation,
// given a certain dominance and selfing coefficient

// Initialisation block
// Define population size, selection coefficients etc.
initialize() {
	defineConstant("locus_size",100000);		// Size of genotype (L)
	// defineConstant("N",500);					//	Pop size
	// defineConstant("Theta",40);				//	Scaled mutation rate, 4NmuL
	// defineConstant("R",120);					//	Scaled rec rate, 2Nr(L-1)
	defineConstant("sel",0.05);					// Homozygote selection coefficient
	defineConstant("BItime",20*N);				// Burn-in time
	defineConstant("EndTime",100*N);				// Stop simulation at this time if nothing has happened
	// defineConstant("x0",0.05);					//	Frequency of neutral mutation when it became selected for
	// defineConstant("h",0.5);					//	Dominance coefficient
	// defineConstant("sfrate",0.5);				//	Self-fertiliastion frequency
	// defineConstant("simID",0);					//	Index for printing out files
	
	mu = Theta/(4*N*locus_size);
	rbp = R/(2*N*(locus_size-1));
	
	initializeMutationRate(mu);
	initializeMutationType("m1", h, "f", 0.0);
	m1.mutationStackPolicy = "f";						// No neutral mutation stacking
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, (locus_size-1));
	initializeRecombinationRate(rbp);
}

// Starting block
// Creating a pop with selfing rate, and setting up timing of other blocks
// BITime = burn-in time; EndTime = stop simulation here if nothing has happened
1 {
	outseed = paste(getSeed());
	writeFile("/Users/hartfield/Documents/SoftSweeps/SLiM/Seeds/SeedsRun" + simID + ".dat", outseed, append=F);
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	sim.rescheduleScriptBlock(s1,BItime,BItime);
	sim.rescheduleScriptBlock(s2,BItime,EndTime);
	sim.rescheduleScriptBlock(s3,EndTime+1,EndTime+1);
	sim.rescheduleScriptBlock(s4,EndTime,EndTime);
}

// 'Choosing mutation' block
// Picks a random neutral mutation to track
s1 10 late() {
	// save the state of the simulation
	sim.outputFull("/Users/hartfield/Documents/SoftSweeps/SLiM/BIPops/BIPop" + simID + ".dat");
	bmut = sample(sim.mutations, 1);		// Choosing base neutral mutant to track
	if(exists("MutID"))
		rm("MutID",removeConstants=T);
	defineConstant("MutID",bmut.id);
}

// Tracking mutation block
// Tracks chosen neutral mutation until it reaches target frequency
// Or goes extinct (either loss or fixation - in any case it is not in memory)
s2 20 late() {
	
	bmut=sim.mutations[sim.mutations.id==MutID];
	
	// Does mutation exist?
	// If so and at target frequency, changed to selected
	doexist = size(bmut);
	if(doexist)
		if((sim.mutationFrequencies(p1, bmut) == x0))
		{
			bmut.setSelectionCoeff(sel);
			ct=sim.generation;
			sim.rescheduleScriptBlock(s2,EndTime+1,EndTime+1);
			sim.rescheduleScriptBlock(s3,ct+1,EndTime);
			sim.rescheduleScriptBlock(s4,EndTime,EndTime);
		}
	
	//	If does not exist, re-do mutation choosing block
	// and re-time other blocks accordingly
	if(!doexist)
	{
		ct=sim.generation;
		sim.rescheduleScriptBlock(s1,ct+1,ct+1);
		sim.rescheduleScriptBlock(s2,ct+1,EndTime);
		sim.rescheduleScriptBlock(s4,EndTime,EndTime);
	}

}

// Tracking selected mutation block
// Tracks the selected mutation until fixation or loss
s3 10 late(){
	
	bmut=sim.mutations[sim.mutations.id==MutID];
	pos=bmut.position;
	
	if (sum(sim.mutations.selectionCoeff) == 0.0)
	{
		// If lost, reintroduce saved background state and try again
		if (sum(sim.substitutions.selectionCoeff) == 0.0)
		{
			// cat("Sweep mutation lost in gen. " + sim.generation + "\n");
			sim.readFromPopulationFile("/Users/hartfield/Documents/SoftSweeps/SLiM/BIPops/BIPop" + simID + ".dat");
			// start a newly seeded run by incrementing the previous seed
			setSeed(getSeed() + 1);
			
			// Resetting block schedules
			ct=sim.generation;
			sim.rescheduleScriptBlock(s1,ct+1,ct+1);
			sim.rescheduleScriptBlock(s2,ct+1,EndTime);
			sim.rescheduleScriptBlock(s3,EndTime+1,EndTime+1);
			sim.rescheduleScriptBlock(s4,EndTime,EndTime);
		}
		else
		{
			ssub=paste((sim.substitutions[sim.substitutions.selectionCoeff>0].position)/locus_size);
			writeFile("/Users/hartfield/Documents/SoftSweeps/SLiM/SweepPos/PosRun" + simID + ".dat", ssub, append=F);
			cat("Sweep mutation reached fixation.\n");
			// sim.outputFull(filePath="/Users/hartfield/Documents/SoftSweeps/SLiM/Populations/Pop" + simID + ".dat");
			// Printing out 10 samples of 'sps' from the population
			for(i in 1:sps){
				p1.outputMSSample(sps,replace=F,filePath="/Users/hartfield/Documents/SoftSweeps/SLiM/Mutations/RawMut" + (10*simID + i) + ".dat",append=F,filterMonomorphic=T);
			}
			sim.simulationFinished();
		}
	}
}

// End simulation block
// If simulation goes on long enough without finding an appropriate mutation,
// ends with warning
s4 10 late() {
	cat("NO SUITABLE MUTATION FOUND AT END OF TIME.\n");
	sim.simulationFinished();
}
