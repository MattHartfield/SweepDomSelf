// Wed 21st Nov 2018
// Modification of recipe 10.6.1
// Selective sweep at a neutral locus from std variation,
// given a certain dominance and selfing coefficient

// To do:
// See if easy to only sample in vicinity of sweep, otherwise do it afterwards in R
// Test code, make sure all works as it should
// Add in commands so that one can feed in variables from command line
// Tidy up print commands where no longer needed

// Initialisation block
// Define population size, selection coefficients etc.
initialize() {
	defineConstant("locus_size",100000);
	defineConstant("N",500);
	defineConstant("Theta",40);
	defineConstant("R",120);
	defineConstant("sel",0.1);
	defineConstant("h",0.5);
	defineConstant("sfrate",0.5);
	defineConstant("BItime",10*N);
	defineConstant("x0",0.05);
	defineConstant("EndTime",20*N);
	
	mu = Theta/(4*N*locus_size);
	rbp = R/(2*N*(locus_size-1));
	
	initializeMutationRate(mu);
	initializeMutationType("m1", h, "f", 0.0);
	m1.mutationStackPolicy = "f";						// No neutral mutation stacking
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, locus_size-1);
	initializeRecombinationRate(rbp);
}

// Starting block
// Creating a pop with selfing rate, and setting up timing of other blocks
// BITime = burn-in time; EndTime = stop simulation here if nothing has happened
1 {
	// save this run's identifier, used to save and restore
	defineConstant("simID", getSeed());
	
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	sim.rescheduleScriptBlock(s1,BItime,BItime);
	sim.rescheduleScriptBlock(s2,BItime,EndTime);
	sim.rescheduleScriptBlock(s3,EndTime+1,EndTime+1);
	sim.rescheduleScriptBlock(s4,EndTime,EndTime);
}

// 'Choosing mutation' block
// Picks a random neutral mutation to track
s1 10 late() {
	// save the state of the simulation
	sim.outputFull("/Users/hartfield/Documents/SoftSweeps/SLiM/Sim" + simID + ".txt");
	muts = sim.mutations;
	bmut = sample(muts, 1);		// Choosing base neutral mutant to track
	if(exists("MutID"))
		rm("MutID",removeConstants=T);
	defineConstant("MutID",bmut.id);
}

// Tracking mutation block
// Tracks chosen neutral mutation until it reaches target frequency
// Or goes extinct (either loss or fixation - in any case it is not in memory)
s2 20 late() {
	
	print(sim.generation);
	bmut=sim.mutations[sim.mutations.id==MutID];
	print(bmut);
	print(bmut.position);
	print(sim.mutationFrequencies(p1, bmut));
	print(size(bmut));
	cat("\n");
	
	doexist = size(bmut);
	// Does mutation exist?
	// If so and at target frequency, changed to selected
	if(doexist)
		if((sim.mutationFrequencies(p1, bmut) == x0))
		{
			bmut.setSelectionCoeff(sel);
			cat("Setting chosen allele as selected mutation.\n");
			cat("\n");
			ct=sim.generation;
			sim.rescheduleScriptBlock(s2,EndTime+1,EndTime+1);
			// sim.deregisterScriptBlock(s2);
			sim.rescheduleScriptBlock(s3,ct+1,EndTime);
			sim.rescheduleScriptBlock(s4,EndTime,EndTime);
			//			sim.simulationFinished();
		}
	
	//	If does not exist, re-do mutation choosing block
	// and re-time other blocks accordingly
	if(!doexist)
	{
		cat("Chosen allele went extinct.\n");
		cat("\n");
		ct=sim.generation;
		sim.rescheduleScriptBlock(s1,ct+1,ct+1);
		sim.rescheduleScriptBlock(s2,ct+1,EndTime);
		sim.rescheduleScriptBlock(s4,EndTime,EndTime);
	}
	
	cat("Sum of sel coefficients is " + sum(sim.mutations.selectionCoeff) + "\n");

}

// Tracking selected mutation block
// Tracks the selected mutation until fixation or loss
s3 10 late(){
	
	print(sim.generation);
	bmut=sim.mutations[sim.mutations.id==MutID];
	print(bmut);
	print(bmut.position);
	print(sim.mutationFrequencies(p1, bmut));
	print(size(bmut));
	cat("\n");
	
	if (sum(sim.mutations.selectionCoeff) == 0.0)
	{
		// If lost, reintroduce saved background state and try again
		if (sum(sim.substitutions.selectionCoeff) == 0.0)
		{
			cat("Sweep mutation lost in gen. " + sim.generation + "\n");
			sim.readFromPopulationFile("/Users/hartfield/Documents/SoftSweeps/SLiM/Sim" + simID + ".txt");			
			// start a newly seeded run by incrementing the previous seed
			setSeed(getSeed() + 1);
			
			// Resetting block schedules
			ct=sim.generation;
			sim.rescheduleScriptBlock(s1,ct+1,ct+1);
			sim.rescheduleScriptBlock(s2,ct+1,EndTime);
			sim.rescheduleScriptBlock(s3,EndTime+1,EndTime+1);
			sim.rescheduleScriptBlock(s4,EndTime,EndTime);
		}
		else
		{
			cat("Sweep mutation reached fixation.\n");
			// To do: sample from final state, within specific range of the target?
			for(i in 1:10){
				p1.outputSample(10,replace=F);
				cat("\n");
			}
			sim.simulationFinished();
		}
	}
}

// End simulation block
// If simulation goes on long enough without finding an appropriate mutation,
// ends with warning
s4 10 late() {
	cat("NO SUITABLE MUTATION FOUND AT END OF TIME.\n");
	sim.simulationFinished();
}
