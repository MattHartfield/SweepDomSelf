// Wed 21st Nov 2018
// Modification of recipe 10.6.1
// Selective sweep at a neutral locus from std variation,
// given a certain dominance and selfing coefficient

// V2: Now looking for allele within set range of the target x0

// V3: After initial burn-in, continues until mutation found at freq x0, then convert to sweep

// V5: To be safe, if selected allele is lost, then simulation stops

// Initialisation block
// Define population size, selection coefficients etc.
initialize() {
	defineConstant("locus_size",100000);	// Size of genotype (L)
	defineConstant("sel",0.05);				// Homozygote selection coefficient
	
//	defineConstant("N",500);					//	Pop size
//	defineConstant("Theta",40);				//	Scaled mutation rate, 4NmuL
//	defineConstant("R",120);					//	Scaled rec rate, 2Nr(L-1)
//	defineConstant("x0",0.05);					//	Frequency of neutral mutation when it became selected for
//	defineConstant("h",0.5);					//	Dominance coefficient
//	defineConstant("sfrate",0);				//	Self-fertiliastion frequency
//	defineConstant("simID",0);					//	Index for printing out files
//	defineConstant("sps",10);					// Number of samples to take
//	defineConstant("numsamp",10);				// Number of times to sample from final population
	
	defineConstant("BItime",20*N);			// Burn-in time
	defineConstant("EndTime",100*N);			// Stop simulation at this time if no mutations have fixed
	
	mu = Theta/(4*N*locus_size);
	rbp = R/(2*N*(locus_size-1));
	
	initializeMutationRate(mu);
	initializeMutationType("m1", h, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, (locus_size-1));
	initializeRecombinationRate(rbp);
}

// Starting block
// Creating a pop with selfing rate, and setting up timing of other blocks
// BITime = burn-in time; EndTime = stop simulation here if nothing has happened
1 {
	outseed = paste(getSeed());
	writeFile("Seeds/SeedsRun" + simID + ".dat", outseed, append=F);
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	sim.rescheduleScriptBlock(s1,BItime,EndTime);
	sim.rescheduleScriptBlock(s3,EndTime+1,EndTime+1);
	sim.rescheduleScriptBlock(s4,EndTime,EndTime);
}

// 'Choosing mutation' block
// Sees if there exists mutation at frequency x0
// If so, set to selected
s1 10 late() {
	// save the state of the simulation
	muts = sim.mutations;
	muts = muts[sim.mutationFrequencies(p1, muts) == x0];
	
	if(size(muts) != 0)
	{	
		cat("Selected mutation introduced in generation " + sim.generation + "\n");
		sim.outputFull("BIPops/BIPop" + simID + ".dat");
		bmut = sample(muts, 1);
		bmut.setSelectionCoeff(sel);
		
		// Rescheduling blocks
		ct=sim.generation;
		sim.rescheduleScriptBlock(s1,EndTime+1,EndTime+1);
		sim.rescheduleScriptBlock(s3,ct+1,EndTime);
		sim.rescheduleScriptBlock(s4,EndTime,EndTime);
	}
}

// Tracking selected mutation block
// Tracks the selected mutation until fixation or loss
s3 10 late(){
	
	if (sum(sim.mutations.selectionCoeff) == 0.0)
	{
		// If lost, reintroduce saved background state and try again
		if (sum(sim.substitutions.selectionCoeff) == 0.0)
		{
			cat("Sweep mutation lost in gen. " + sim.generation + "\n");				
		}
		else
		{
			ssub=paste((sim.substitutions[sim.substitutions.selectionCoeff>0].position)/locus_size);
			writeFile("SweepPos/PosRun" + simID + ".dat", ssub, append=F);
			cat("Sweep mutation reached fixation.\n");
		
			// Printing out 10 samples of 'numsamp' from the population
			for(i in 1:numsamp){
				p1.outputMSSample(sps,replace=F,filePath="Mutations/RawMut" + (numsamp*simID + i) + ".dat",append=F,filterMonomorphic=T);
			}
		}
		sim.simulationFinished();
	}
}

// End simulation block
// If simulation goes on long enough without finding an appropriate mutation,
// ends with warning
s4 10 late() {
	cat("NO SUITABLE MUTATION FOUND AT END OF TIME.\n");
	sim.simulationFinished();
}
