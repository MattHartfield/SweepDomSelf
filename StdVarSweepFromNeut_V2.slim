// Wed 21st Nov 2018
// Modification of recipe 10.6.1
// Selective sweep at a neutral locus from std variation,
// given a certain dominance and selfing coefficient

// V2: Now looking for allele within set range of the target X0

// Initialisation block
// Define population size, selection coefficients etc.
initialize() {
	defineConstant("locus_size",100000);	// Size of genotype (L)
	defineConstant("N",500);					//	Pop size
	defineConstant("Theta",40);				//	Scaled mutation rate, 4NmuL
	defineConstant("R",120);					//	Scaled rec rate, 2Nr(L-1)
	defineConstant("sel",0.05);				// Homozygote selection coefficient
	defineConstant("BItime",20*N);			// Burn-in time
	defineConstant("EndTime",100*N);			// Stop simulation at this time if nothing has happened
	defineConstant("x0",0.05);					//	Frequency of neutral mutation when it became selected for
	defineConstant("h",0.5);					//	Dominance coefficient
	defineConstant("sfrate",0.5);				//	Self-fertiliastion frequency
	defineConstant("simID",0);					//	Index for printing out files
	defineConstant("sps",10);					// Number of times to sample from final population
	defineConstant("lx0",x0-0.005);	 		// Lower bound of neutral mutation to choose from
	defineConstant("ux0",x0+0.005);	 		// Upper bound of neutral mutation to choose from
	
	mu = Theta/(4*N*locus_size);
	rbp = R/(2*N*(locus_size-1));
	
	initializeMutationRate(mu);
	initializeMutationType("m1", h, "f", 0.0);
	m1.mutationStackPolicy = "f";						// No neutral mutation stacking
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, (locus_size-1));
	initializeRecombinationRate(rbp);
}

// Starting block
// Creating a pop with selfing rate, and setting up timing of other blocks
// BITime = burn-in time; EndTime = stop simulation here if nothing has happened
1 {
	outseed = paste(getSeed());
	writeFile("/Users/hartfield/Documents/SoftSweeps/SLiM/Seeds/SeedsRun" + simID + ".dat", outseed, append=F);
	sim.addSubpop("p1", N);
	p1.setSelfingRate(sfrate);
	sim.rescheduleScriptBlock(s1,BItime,BItime);
	sim.rescheduleScriptBlock(s3,BItime,EndTime);
	sim.rescheduleScriptBlock(s4,EndTime,EndTime);
}

// 'Choosing mutation' block
// Picks a random neutral mutation to track
// Sets it as selected then tracks it
s1 10 late() {
	// save the state of the simulation
	sim.outputFull("/Users/hartfield/Documents/SoftSweeps/SLiM/BIPops/BIPop" + simID + ".dat");
	muts = sim.mutations;
	muts = muts[sim.mutationFrequencies(p1, muts) == x0];
//	print(size(muts));
//	print(sim.mutationFrequencies(p1,muts));
//	print(muts.id);
	if(size(muts) == 0)
	{
		muts = sim.mutations;
		muts = muts[((sim.mutationFrequencies(p1, muts) > lx0) & (sim.mutationFrequencies(p1, muts) < ux0))];
//		print(size(muts));
//		print(sim.mutationFrequencies(p1,muts));
//		print(muts.id);
		if(size(muts) == 0)
		{
			cat("NO SUITABLE MUTATION FOUND AT BURN IN.\n");
			sim.simulationFinished();
		}
	}	
	bmut = sample(muts, 1);
//	if(exists("MutID"))
//		rm("MutID",removeConstants=T);
//	defineConstant("MutID",bmut.id);
//	print(bmut.id);
	bmut.setSelectionCoeff(sel);
	ct=sim.generation;
//	sim.simulationFinished();
}

// Tracking selected mutation block
// Tracks the selected mutation until fixation or loss
s3 10 late(){
	
	if (sum(sim.mutations.selectionCoeff) == 0.0)
	{
		// If lost, reintroduce saved background state and try again
		if (sum(sim.substitutions.selectionCoeff) == 0.0)
		{
			// cat("Sweep mutation lost in gen. " + sim.generation + "\n");
			sim.readFromPopulationFile("/Users/hartfield/Documents/SoftSweeps/SLiM/BIPops/BIPop" + simID + ".dat");
			// start a newly seeded run by incrementing the previous seed
			setSeed(getSeed() + 1);
			
			// Resetting block schedules
			ct=sim.generation;
			sim.rescheduleScriptBlock(s1,ct+1,ct+1);
			sim.rescheduleScriptBlock(s3,ct+1,EndTime);
			sim.rescheduleScriptBlock(s4,EndTime,EndTime);
		}
		else
		{
			ssub=paste((sim.substitutions[sim.substitutions.selectionCoeff>0].position)/locus_size);
			writeFile("/Users/hartfield/Documents/SoftSweeps/SLiM/SweepPos/PosRun" + simID + ".dat", ssub, append=F);
			cat("Sweep mutation reached fixation.\n");
			// sim.outputFull(filePath="/Users/hartfield/Documents/SoftSweeps/SLiM/Populations/Pop" + simID + ".dat");
			// Printing out 10 samples of 'sps' from the population
			for(i in 1:sps){
				p1.outputMSSample(sps,replace=F,filePath="/Users/hartfield/Documents/SoftSweeps/SLiM/Mutations/RawMut" + (10*simID + i) + ".dat",append=F,filterMonomorphic=T);
			}
			sim.simulationFinished();
		}
	}
}

// End simulation block
// If simulation goes on long enough without finding an appropriate mutation,
// ends with warning
s4 10 late() {
	cat("NO SUITABLE MUTATION FOUND AT END OF TIME.\n");
	sim.simulationFinished();
}
